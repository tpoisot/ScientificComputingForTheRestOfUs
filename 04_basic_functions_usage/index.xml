<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://sciencecomputing.io/04_basic_functions_usage/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://sciencecomputing.io/04_basic_functions_usage/index.xml" rel="self" type="application/rss+xml"/><item><title>Broadcasting and the dot notation</title><link>https://sciencecomputing.io/functions/broadcasting-and-the-dot-notation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/functions/broadcasting-and-the-dot-notation/</guid><description>&lt;p>In some of the previous modules, we have used a notation that looked like
&lt;code>function.(arguments)&lt;/code>, or &lt;code>x .+ y&lt;/code>. In this module, we will talk about what
the &lt;code>.&lt;/code> notation does, and more broadly, what &lt;em>broadcasting&lt;/em> is.&lt;/p></description></item><item><title>Declaring functions</title><link>https://sciencecomputing.io/functions/declaring-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/functions/declaring-functions/</guid><description>&lt;p>Everything should be a function. Everything. Especially in &lt;em>Julia&lt;/em>, for
performance related reasons that are far beyond the scope of this material. So
one of the first, most significant piece of knowledge to acquire is: how do I
declare a function?&lt;/p></description></item><item><title>Documenting functions</title><link>https://sciencecomputing.io/functions/documenting-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/functions/documenting-functions/</guid><description>&lt;p>In this module, we will look at what is probably the most important part of writing
a function: writing its documentation. By the end of this module, you will be able to
write a docstring for your function that is accessible through &lt;em>Julia&lt;/em>&amp;rsquo;s help mode.&lt;/p></description></item><item><title>Keyword arguments and splatting</title><link>https://sciencecomputing.io/functions/keyword-arguments-and-splatting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/functions/keyword-arguments-and-splatting/</guid><description>&lt;p>In the previous modules, we have defined functions that used &lt;em>positional&lt;/em>
arguments, some with default values, some without. In this module, we will
look at keyword arguments and splatting, to build functions that we can
control a bit more.&lt;/p></description></item><item><title>Multiple dispatch in practice</title><link>https://sciencecomputing.io/functions/multiple-dispatch-in-practice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/functions/multiple-dispatch-in-practice/</guid><description>&lt;p>In this module, we will expand on the previous content (understanding
&lt;em>dispatch&lt;/em>) to get familiar with a central design paradigm of &lt;em>Julia&lt;/em>:
multiple dispatch. We will do so by writing code to simulate the growth of a
population in space.&lt;/p></description></item><item><title>Returning functions</title><link>https://sciencecomputing.io/functions/returning-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/functions/returning-functions/</guid><description>&lt;p>In this module, we will learn how we can write functions that return other
functions. Because this seems a little weird at first, we will also discuss
situations in which this is a useful design pattern, and see how this approach
can be used together with Julia&amp;rsquo;s powerful dispatch system.&lt;/p></description></item><item><title>Understanding dispatch</title><link>https://sciencecomputing.io/functions/understanding-dispatch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/functions/understanding-dispatch/</guid><description>&lt;p>The point of this module is to understand &lt;em>dispatch&lt;/em>, which is to say, the way
the correct method is called based on the arguments; we will also see how to
use it to write the least possible amount of code!&lt;/p></description></item></channel></rss>