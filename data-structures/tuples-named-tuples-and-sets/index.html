<!doctype html><html><head>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta charset=utf-8>
<link href=/fonts/fontawesome/css/fontawesome.css rel=stylesheet>
<link href=/fonts/fontawesome/css/brands.css rel=stylesheet>
<link href=/fonts/fontawesome/css/solid.css rel=stylesheet>
<script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0,theme:"neutral",curve:"linear"})</script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script>
<link rel=stylesheet href=https://sciencecomputing.io/index.818233115a5ddaf75da6d0ea23b08181cba7bdd5657dda146098a1d667db9950.css>
<title>Tuples, named tuples, and sets · Scientific computing</title></head><body><header>
<div id=reading-bar><div id=reading-bar-inner></div></div><img class=logo src=/logo.svg>
<h1><a href=/>Scientific computing</a></h1><h2>(for the rest of us)</h2></header><main>
<h1>Tuples, named tuples, and sets</h1><article>
<p>In this module, we will explore data structures that look a lot like arrays,
but have subtly different use cases: tuples, named tuples, and sets. Knowing
when to use arrays and when to use others data structure can really make a
difference in your programming!s</p><p>One important feature of arrays is that they are <em>mutable</em>. For example, if we write</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>x</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=n>x</span>
</span></span></code></pre></div><pre tabindex=0><code>3-element Vector{Int64}:
 1
 3
 3
</code></pre><p>we have modified the value of `x``. In some cases, we care a lot about data
integrity in a collection. This is, for example, the case with model
hyper-parameters, for which we do not want to see a change.</p><p>In a nutshell, this is what tuples do (they do a little more than that, and it
is, as you have guessed, written down in the documentation).</p><p>A tuple is declared using parentheses instead of square brackets:s</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>(1, 2, 3)
</code></pre><p>By contrast to the array, we cannot modify values in a tuple:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=k>try</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=k>catch</span> <span class=n>error</span>
</span></span><span class=line><span class=cl>    <span class=nd>@info</span> <span class=n>typeof</span><span class=p>(</span><span class=n>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></div><pre tabindex=0><code>[ Info: MethodError
</code></pre><p>Note that this is a <code>MethodError</code>: there is no instruction in <em>Julia</em> to let
the user modify a tuple!</p><p>In short, values in a tuple are <em>safe</em>, because they can be read (<code>a[2]</code> would
return the second element), but not written to. But tuple can do something
absolutely fantastic:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>z</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>y</span>
</span></span></code></pre></div><pre tabindex=0><code>2
</code></pre><p>They can store values, and this allows us to <em>unpack</em> these tuples into
arguments. This is a great way to safely store values (tuples are impossible
to alter) until we are ready to use them with more explicit names.</p><p>Although we have written the tuple using the position of arguments, it is
possible to use a structure called a <em>named</em> tuple, in which the fields of the
tuple have names.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>parameters</span> <span class=o>=</span> <span class=p>(</span><span class=n>r</span> <span class=o>=</span> <span class=mf>0.8</span><span class=p>,</span> <span class=n>K</span> <span class=o>=</span> <span class=mf>1.0</span><span class=p>,</span> <span class=n>A</span> <span class=o>=</span> <span class=mf>0.2</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>(r = 0.8, K = 1.0, A = 0.2)
</code></pre><p>We can access these fields using the dot notation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>parameters</span><span class=o>.</span><span class=n>r</span>
</span></span></code></pre></div><pre tabindex=0><code>0.8
</code></pre><p>or with the <code>getfield</code> function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>getfield</span><span class=p>(</span><span class=n>parameters</span><span class=p>,</span> <span class=ss>:K</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>1.0
</code></pre><p>Note that tuples have a fairly intricate type:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>typeof</span><span class=p>(</span><span class=n>parameters</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>NamedTuple{(:r, :K, :A), Tuple{Float64, Float64, Float64}}
</code></pre><p>This goes far beyond the scope of this material, but the type of this tuple
actually account for the <em>name</em> of its fields!</p><div class="callout information">One exteremely powerful use of named tuples is to splat them when
calling functions. We will get to this point later on, when spending quite a
lot of time exploring how functions work.</div><p>An addition way to store a collection of data is to use a <code>Set</code>. Sets are
exactly that, a translation of the mathematical object of a set, from set
theory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>s1</span> <span class=o>=</span> <span class=kt>Set</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>])</span>
</span></span></code></pre></div><pre tabindex=0><code>Set{Int64} with 3 elements:
  2
  3
  1
</code></pre><p>Notice that the order or the elements is not maintained! Operations on sets
follow the mathematical convention:s</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>s2</span> <span class=o>=</span> <span class=kt>Set</span><span class=p>([</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>])</span>
</span></span></code></pre></div><pre tabindex=0><code>Set{Int64} with 4 elements:
  5
  4
  2
  3
</code></pre><p>For example, the <code>\cap</code> operator will perform an intersection (see also
<code>intersect</code>):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>s1</span> <span class=o>∩</span> <span class=n>s2</span>
</span></span></code></pre></div><pre tabindex=0><code>Set{Int64} with 2 elements:
  2
  3
</code></pre><p>The union is done with <code>\cup</code> (see also <code>union</code>):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>s1</span> <span class=o>∪</span> <span class=n>s2</span>
</span></span></code></pre></div><pre tabindex=0><code>Set{Int64} with 5 elements:
  5
  4
  2
  3
  1
</code></pre><p>There is also a <code>setdiff</code> function for set differences:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>setdiff</span><span class=p>(</span><span class=n>s1</span><span class=p>,</span> <span class=n>s2</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>Set{Int64} with 1 element:
  1
</code></pre><p>Note that <code>setdiff</code> is sensitive to the order of its arguments:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>setdiff</span><span class=p>(</span><span class=n>s2</span><span class=p>,</span> <span class=n>s1</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>Set{Int64} with 2 elements:
  5
  4
</code></pre><p>A big difference with the tuples is that sets cannot be indexed (because the
elements are <em>not</em> sorted), but it is possible to <em>add</em> elements to a set:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>push!</span><span class=p>(</span><span class=n>s2</span><span class=p>,</span> <span class=mi>6</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>Set{Int64} with 5 elements:
  5
  4
  6
  2
  3
</code></pre><p>A second difference is that sets only store <em>unique</em> values, so pushing the
value <code>6</code> a second time will not be an issue:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>push!</span><span class=p>(</span><span class=n>s2</span><span class=p>,</span> <span class=mi>6</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>Set{Int64} with 5 elements:
  5
  4
  6
  2
  3
</code></pre><p>Sets are very useful at representing a group of entities for which the order
is unimportant, but the entries must be unique. Tuples are very good at
storing data that you may want to name, but that you certainly do not want to
modify.</p></article></main><footer>
<div class=wrapper>
<a href=/about/>About this project</a>
<a href=https://github.com/tpoisot/ScientificComputingForTheRestOfUs target=_blank>See the project on GitHub</a>
<a href="https://github.com/tpoisot/ScientificComputingForTheRestOfUs/issues/new?labels=section-data_structures,module-tuples,status-rc,feedback&assignees=@tpoisot&title=ADD%20A%20DESCRIPTIVE%20TITLE&body=%20**Description%20of%20your%20problem/comments**%0a%0a%0a%0a---%0a*Do%20not%20edit%20below%20this%20point*%0a%0a[%f0%9f%92%bb%20SOURCE][src]%0a%0a[src]:%20https://github.com/tpoisot/ScientificComputingForTheRestOfUs/blob/main/content/02_data_structures/04_tuples.jl%0a%0a[%f0%9f%93%94%20PAGE][prm]%0a%0a[prm]:%20https://sciencecomputing.io/data-structures/tuples-named-tuples-and-sets/%0a%0a%f0%9f%93%a6%20section-data_structures%0a%0a%f0%9f%8f%b7%ef%b8%8f%20module-tuples" target=_blank>Provide feedback on this module</a>
<a href=https://creativecommons.org/licenses/by/4.0/ target=_blank>CC-BY 4.0 (Timothée Poisot)</a>
</div></footer></body><script>const readingBarInner=document.querySelector("#reading-bar-inner");document.addEventListener("scroll",function(){let e=(document.body.scrollTop||document.documentElement.scrollTop)/(document.documentElement.scrollHeight-document.documentElement.clientHeight)*100;readingBarInner.style.setProperty("width",e+"%")})</script>
</html>