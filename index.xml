<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Welcome! on</title><link>https://sciencecomputing.io/</link><description>Recent content in Welcome! on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://sciencecomputing.io/index.xml" rel="self" type="application/rss+xml"/><item><title>A gentle introduction to for loops</title><link>https://sciencecomputing.io/flow/a-gentle-introduction-to-for-loops/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/flow/a-gentle-introduction-to-for-loops/</guid><description>&lt;p>Oh no. Oh no no no. This is &lt;em>not&lt;/em> a fun module. This will not be pleasant. But
this will, very much, be necessary and incredibly empowering. Sit down, buckle
up, we&amp;rsquo;re about to see what loops do.&lt;/p></description></item><item><title>About this material</title><link>https://sciencecomputing.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/about/</guid><description>This material is aimed at people who have already interacted with a computer using a programming language, but want to adopt best practices that make their code more robust, more maintainable, and easier to understand. It can also be used to facilitate the onboarding of new people in your lab or your project. In particular, this material was designed for learners who do not have a background in programming and computer science; more specifically still, this content is mostly used with biologists, but there should be something in here for most people wanting to adopt better practices towards scientific computing.</description></item><item><title>Advanced iteration</title><link>https://sciencecomputing.io/flow/advanced-iteration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/flow/advanced-iteration/</guid><description>&lt;p>In this module, we will see how we &lt;em>actually&lt;/em> iterate over objects in &lt;em>Julia&lt;/em>.
Although the content of the previous module is very important, as it forms the
basis of all ways to iterate, there are a number of functions that greatly
facilitate our task. We finish this module by simulating a simple
host-parasitoid model.&lt;/p></description></item><item><title>Advanced string manipulation</title><link>https://sciencecomputing.io/advanced-topics/advanced-string-manipulation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/advanced-topics/advanced-string-manipulation/</guid><description/></item><item><title>An introduction to arrays</title><link>https://sciencecomputing.io/data-structures/an-introduction-to-arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/data-structures/an-introduction-to-arrays/</guid><description>&lt;p>A &lt;em>lot&lt;/em> of scientific computing eventually boils down to accessing things in
structures that look like vectors or matrices. In this module, we will examine
the basic syntax to create, interact with, and transpose these structures. This is
one of the most foundational module in the class, as we will be using an
absurd quantity of vectors and matrices moving forward.&lt;/p></description></item><item><title>Broadcasting and the dot notation</title><link>https://sciencecomputing.io/functions/broadcasting-and-the-dot-notation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/functions/broadcasting-and-the-dot-notation/</guid><description>&lt;p>In some of the previous modules, we have used a notation that looked like
&lt;code>function.(arguments)&lt;/code>, or &lt;code>x .+ y&lt;/code>. In this module, we will talk about what
the &lt;code>.&lt;/code> notation does, and more broadly, what &lt;em>broadcasting&lt;/em> is.&lt;/p></description></item><item><title>Building our own graph library</title><link>https://sciencecomputing.io/applications/building-our-own-graph-library/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/applications/building-our-own-graph-library/</guid><description>&lt;p>In this module,&lt;/p></description></item><item><title>Building your own types</title><link>https://sciencecomputing.io/data-structures/building-your-own-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/data-structures/building-your-own-types/</guid><description>&lt;p>In this module, we will &lt;em>briefly&lt;/em> see how we can define our own types (&lt;em>aka&lt;/em>
&lt;code>struct&lt;/code>), and give them a hierarchy. We will barely scratch the surface of
what can be done with custom types, as the real fun will take place in the
modules on &lt;a href="https://sciencecomputing.io/functions/understanding-dispatch/">dispatch&lt;/a> and &lt;a href="https://sciencecomputing.io/advanced-topics/overloading/">overloading&lt;/a> (don&amp;rsquo;t read
them yet!).&lt;/p></description></item><item><title>Consuming data from APIs</title><link>https://sciencecomputing.io/files/consuming-data-from-apis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/files/consuming-data-from-apis/</guid><description>&lt;p>Not all data come from static files. In a large number of scientific
applications, we need to collect data from websites, often using a &lt;a href="https://www.redhat.com/en/topics/api/what-is-a-rest-api">RESTful
API&lt;/a>. In this module, we will use a very simple example to show how we
can collect data about postal codes, get them as a JSON file, and process
them.&lt;/p></description></item><item><title>Declaring functions</title><link>https://sciencecomputing.io/functions/declaring-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/functions/declaring-functions/</guid><description>&lt;p>Everything should be a function. Everything. Especially in &lt;em>Julia&lt;/em>, for
performance related reasons that are far beyond the scope of this material. So
one of the first, most significant piece of knowledge to acquire is: how do I
declare a function?&lt;/p></description></item><item><title>Dictionaries and pairs</title><link>https://sciencecomputing.io/data-structures/dictionaries-and-pairs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/data-structures/dictionaries-and-pairs/</guid><description>&lt;p>In this module, we will explore two very useful data structures: dictionaries,
which serve as &amp;ldquo;key-value&amp;rdquo; stores, and pairs, which serve as (essentially) the
same thing but smaller.&lt;/p></description></item><item><title>Dispatch on element types</title><link>https://sciencecomputing.io/advanced-functions/dispatch-on-element-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/advanced-functions/dispatch-on-element-types/</guid><description>&lt;p>In this lesson, we will see how we can dispatch on parametric types, in order
to have a fine-grained control on what method is used for different
types of data collections. This is a core design pattern in &lt;em>Julia&lt;/em>, and we will
illustrate it by building some functions related to measuring the distances between
points.&lt;/p></description></item><item><title>Documenting functions</title><link>https://sciencecomputing.io/functions/documenting-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/functions/documenting-functions/</guid><description>&lt;p>In this module, we will look at what is probably the most important part of writing
a function: writing its documentation. By the end of this module, you will be able to
write a docstring for your function that is accessible through &lt;em>Julia&lt;/em>&amp;rsquo;s help mode.&lt;/p></description></item><item><title>Downloading files</title><link>https://sciencecomputing.io/files/downloading-files/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/files/downloading-files/</guid><description>&lt;p>In this module, we will see how &lt;em>Julia&lt;/em> allows downloading files from the
internet, and how we can decide where to store them. This is a common task
when getting external data, and will be the basis of a number of advanced
training modules in the final section of this material.&lt;/p></description></item><item><title>Environment and projects</title><link>https://sciencecomputing.io/introduction/environment-and-projects/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/introduction/environment-and-projects/</guid><description>&lt;p>In this previous module, we did not load a single package: everything we
wanted to do was provided by &lt;em>Julia&lt;/em> &amp;ldquo;out of the box&amp;rdquo;. In most applications,
we will need to get functionalities from other packages, and this is where
&lt;em>Julia&lt;/em>&amp;rsquo;s package manager shines.&lt;/p></description></item><item><title>Error handling with try</title><link>https://sciencecomputing.io/flow/error-handling-with-try/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/flow/error-handling-with-try/</guid><description>&lt;p>In previous modules, we have used a &lt;code>try&lt;/code>/&lt;code>catch&lt;/code> statement. In this module,
we will go into some detail about what it means, and how to use them to write
code that handles errors gracefully.&lt;/p></description></item><item><title>Exiting loops</title><link>https://sciencecomputing.io/flow/exiting-loops/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/flow/exiting-loops/</guid><description>&lt;p>In the previous two modules, we have written loops that terminate when a
condition is met (&lt;code>while&lt;/code>), or when the collection has been iterated over
entirely (&lt;code>for&lt;/code>). In some cases, we may want to fine-tune the behavior of our
iteration. In these cases, we can use some special keywords to jump out of the
loop entirely, or skip some steps.&lt;/p></description></item><item><title>Finding things in arrays</title><link>https://sciencecomputing.io/advanced-topics/finding-things-in-arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/advanced-topics/finding-things-in-arrays/</guid><description>&lt;p>In this module, we will see how to locate interesting values in collections,
and how to extract and test the existence of some of these values. This is
important knowledge in order to build more advanced programs, and we will put
it in action in the following section.&lt;/p></description></item><item><title>Flowcharts</title><link>https://sciencecomputing.io/introduction/flowcharts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/introduction/flowcharts/</guid><description>&lt;p>One of the most powerful tool to plan a programming task is to draw a
flowchart. In simple terms, a flowchart will let you map the different steps
that the program will have to follow, and see what is required for each of
them. To illustrate, we will use a flowchart not of a program, but of a
pancake recipe.&lt;/p></description></item><item><title>Growing arrays</title><link>https://sciencecomputing.io/advanced-topics/growing-arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/advanced-topics/growing-arrays/</guid><description/></item><item><title>How to use this material</title><link>https://sciencecomputing.io/howto/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/howto/</guid><description>The best way to read this material is to keep a terminal running Julia open, and type the code. It is tempting to copy and paste, but typing the code actually matters. The sections (and modules within them) are presented in chronological order, and whenever possible (most of the time) introduce one concept at a time. Every so often, an illustration or example will start to re-use previous knowledge, and this gets more common in the later sections.</description></item><item><title>Indexing, slicing, and all that</title><link>https://sciencecomputing.io/data-structures/indexing-slicing-and-all-that/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/data-structures/indexing-slicing-and-all-that/</guid><description>&lt;p>In the previous module, we have introduced the notion of &lt;code>Array&lt;/code>s, and
experimented with the shape of vectors and matrices. In this module, we will
continue our exploration of these objects, and see how we can modify and
access the information they store.&lt;/p></description></item><item><title>Installing Julia</title><link>https://sciencecomputing.io/introduction/installing-julia/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/introduction/installing-julia/</guid><description>&lt;p>In this module, we will see how we can install &lt;em>Julia&lt;/em>, setup a default
version, and go through some of the usual tools involved in setting up a good
&lt;em>Julia&lt;/em> development environment. We will not deal with the installation of
&lt;em>packages&lt;/em> quite yet, as this will be done with its own module.&lt;/p></description></item><item><title>Introduction to Boolean values</title><link>https://sciencecomputing.io/fundamentals/introduction-to-boolean-values/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/fundamentals/introduction-to-boolean-values/</guid><description>&lt;p>In this module, we will get acquainted with one of the most important type of
variables: Boolean values. They represent values that are either &lt;code>true&lt;/code> or
&lt;code>false&lt;/code>, which is a key element in a number of problems.&lt;/p></description></item><item><title>Iteration in action!</title><link>https://sciencecomputing.io/flow/iteration-in-action/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/flow/iteration-in-action/</guid><description>&lt;p>In this module, we will start integrating skills from the previous modules,
both about iteration and about data structures, indexing, slicing, etc. We
will simulate the temporal dynamics of two populations, one of hosts and one
of parasitoids, using a simple time-discrete model.&lt;/p></description></item><item><title>Keyword arguments and splatting</title><link>https://sciencecomputing.io/functions/keyword-arguments-and-splatting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/functions/keyword-arguments-and-splatting/</guid><description>&lt;p>In the previous modules, we have defined functions that used &lt;em>positional&lt;/em>
arguments, some with default values, some without. In this module, we will
look at keyword arguments and splatting, to build functions that we can
control a bit more.&lt;/p></description></item><item><title>Linear regression using gradient descent</title><link>https://sciencecomputing.io/applications/linear-regression-using-gradient-descent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/applications/linear-regression-using-gradient-descent/</guid><description>&lt;p>In this module, we will use the gradient descent algorithm to perform a linear
regression, to estimate the brain mass of an animal if we know its body mass.
This will draw on concepts from a number of previous modules, while also
presenting an example of how core programming skills can be applied for
research.&lt;/p></description></item><item><title>List comprehensions</title><link>https://sciencecomputing.io/advanced-topics/list-comprehensions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/advanced-topics/list-comprehensions/</guid><description/></item><item><title>Map, Filter, Accumulate, Reduce</title><link>https://sciencecomputing.io/advanced-topics/map-filter-accumulate-reduce/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/advanced-topics/map-filter-accumulate-reduce/</guid><description>&lt;p>In a lot of applications, we want to apply some operation to all elements in a
collection, and then aggregate these elements together in a grand unified
answer. In this module, we will have a look at the map-filter-reduce strategy,
as well as the accumulate operation.&lt;/p></description></item><item><title>Multiple dispatch in practice</title><link>https://sciencecomputing.io/functions/multiple-dispatch-in-practice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/functions/multiple-dispatch-in-practice/</guid><description>&lt;p>In this module, we will expand on the previous content (understanding
&lt;em>dispatch&lt;/em>) to get familiar with a central design paradigm of &lt;em>Julia&lt;/em>:
multiple dispatch. We will do so by writing code to simulate the growth of a
population in space.&lt;/p></description></item><item><title>Mutating functions</title><link>https://sciencecomputing.io/advanced-functions/mutating-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/advanced-functions/mutating-functions/</guid><description>&lt;p>In this module, we will see how &lt;em>Julia&lt;/em> deals with collections when they are
passed as arguments to a function, why this can be terrifying when coming from
other languages that are less concerned with economy of memory, and how we can
use this behavior to write more efficient code.&lt;/p></description></item><item><title>Naive Bayes Classifier</title><link>https://sciencecomputing.io/applications/naive-bayes-classifier/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/applications/naive-bayes-classifier/</guid><description>&lt;p>Naive Bayes Classifiers are formidable because they can learn so much about a
dataset based on relatively scarce information. In this module, we will build
one from scratch, using (mostly) methods from &lt;em>Julia&lt;/em>&amp;rsquo;s standard library.&lt;/p></description></item><item><title>Overloading</title><link>https://sciencecomputing.io/advanced-topics/overloading/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/advanced-topics/overloading/</guid><description>&lt;p>Overloading is a &lt;em>very&lt;/em> powerful mechanism, through which we can add methods
to existing functions to make them work with our own types. In this module, we
will discuss how to overload existing functions, and how to use this approach
in practice.&lt;/p></description></item><item><title>Preparing a project</title><link>https://sciencecomputing.io/introduction/preparing-a-project/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/introduction/preparing-a-project/</guid><description>&lt;p>In this module, before we write any code, we will start thinking about what a
project is, how we can set one up on our computer, and why this might help
defeat coder&amp;rsquo;s block.&lt;/p></description></item><item><title>Pseudo-code</title><link>https://sciencecomputing.io/introduction/pseudo-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/introduction/pseudo-code/</guid><description>&lt;p>To facilitate the transition between diagram and code, one important step is
to write &lt;em>pseudo-code&lt;/em>, &lt;em>i.e.&lt;/em> text that looks reasonably like code, but is
not. This pseudo-code will not help the computer think about our problem,
but it might help &lt;em>us&lt;/em> think about the problem in ways that will make the
actual programming easier.&lt;/p></description></item><item><title>Recursion</title><link>https://sciencecomputing.io/advanced-functions/recursion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/advanced-functions/recursion/</guid><description>&lt;p>What is recursion, if not recursion persevering? In this module, we will see
how to call functions recursively, and discuss when this is appropriate in
real life.&lt;/p></description></item><item><title>Returning functions</title><link>https://sciencecomputing.io/functions/returning-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/functions/returning-functions/</guid><description>&lt;p>In this module, we will learn how we can write functions that return other
functions. Because this seems a little weird at first, we will also discuss
situations in which this is a useful design pattern, and see how this approach
can be used together with Julia&amp;rsquo;s powerful dispatch system.&lt;/p></description></item><item><title>Runge-Kutta for numerical integration</title><link>https://sciencecomputing.io/applications/runge-kutta-for-numerical-integration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/applications/runge-kutta-for-numerical-integration/</guid><description/></item><item><title>Short-circuit Boolean operations</title><link>https://sciencecomputing.io/fundamentals/short-circuit-boolean-operations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/fundamentals/short-circuit-boolean-operations/</guid><description>&lt;p>In the &lt;a href="https://sciencecomputing.io/fundamentals/introduction-to-boolean-values/">previous module&lt;/a>, we have introduce important notions about
Boolean values. In this module, we will expand upon this knowledge in ways
that will enable us to be more expressive with the code we write.&lt;/p></description></item><item><title>Strings, symbols, and text</title><link>https://sciencecomputing.io/data-structures/strings-symbols-and-text/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/data-structures/strings-symbols-and-text/</guid><description>&lt;p>In this module, we will look at string and characters, &lt;em>i.e.&lt;/em> representations
of text. These objects are really interesting in &lt;em>Julia&lt;/em> because not only do
they store information, they can store a little bit of computation as well.
The point of this module is to go through the basics of what strings are, and
we will revisit advanced operations in later sections.&lt;/p></description></item><item><title>Suggested readings</title><link>https://sciencecomputing.io/readinglist/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/readinglist/</guid><description>This material is a lot more useful when paired with additional readings. What follows is an uncurated list of things that we consulted when writing and revising it, and are both accessible and illuminating. The point is not to read all of them in one go. The point is not to provide a complete reference bibliography either. In a classroom context, a lot of these articles would be on the syllabus.</description></item><item><title>Testing functions</title><link>https://sciencecomputing.io/advanced-functions/testing-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/advanced-functions/testing-functions/</guid><description>&lt;p>In this module, we will explore the &lt;code>Test&lt;/code> package, which allows to
programmatically test the behavior of a function. We will see how testing can
bring us closer to being confident in our code.&lt;/p></description></item><item><title>The forest-fire model</title><link>https://sciencecomputing.io/applications/the-forest-fire-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/applications/the-forest-fire-model/</guid><description>&lt;p>In this module, we will have a look at indexing in order to simulate the
behavior of a forest when trees can catch on fire, be planted, and regrow.
This is a common example in complex system studies, and produces very visually
pleasing structures in space! As a treat, we will spend a little more time
learning about how &lt;span class='package'>&lt;span class='pkgname'>&lt;a href='https://juliapackages.com/p/Makie' target='_blank'>Makie&lt;/a>&lt;/span>&lt;/span> works.&lt;/p></description></item><item><title>The JSON format</title><link>https://sciencecomputing.io/files/the-json-format/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/files/the-json-format/</guid><description>&lt;p>The JSON format is really interesting to store highly structured information.
In this module, we will see how it maps naturally on the &lt;code>Dict&lt;/code> data
structure, how to use it to load and save data, and how to print the contents
of a JSON file. As an illustration, we will look at the time series of
vaccination against COVID-19 in New Zealand.&lt;/p></description></item><item><title>The Path</title><link>https://sciencecomputing.io/files/the-path/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/files/the-path/</guid><description>&lt;p>One of the main obstacle to reproductible projects is issues with describing
where files are. In this module, we will talk about the path, and how to refer
to locations in a way that will work on any computer.&lt;/p></description></item><item><title>The ternary operator</title><link>https://sciencecomputing.io/fundamentals/the-ternary-operator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/fundamentals/the-ternary-operator/</guid><description>&lt;p>In this module, we will look at the &amp;ldquo;ternary operator&amp;rdquo;, a very efficient
shortcut to perform a logical test in a single line. This is a construct we
will use quite a lot to express both possible outcomes of a conditional expression using
a single line!&lt;/p></description></item><item><title>The travelling salesperson problem</title><link>https://sciencecomputing.io/applications/the-travelling-salesperson-problem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/applications/the-travelling-salesperson-problem/</guid><description>&lt;p>In this module, we will look at a way to start working on the travelling salesperson
problem. This is mostly an excuse to play with simulated annealing, which is a really cool
optimisation algorithm.&lt;/p></description></item><item><title>The while statement</title><link>https://sciencecomputing.io/flow/the-while-statement/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/flow/the-while-statement/</guid><description>&lt;p>In this module, we will see how we can use the &lt;code>while&lt;/code> construct to make a
series of instructions repeat until a condition is met, and how to deal with
common caveats that can arise when using a &lt;code>while&lt;/code> loop.&lt;/p></description></item><item><title>Tuples, named tuples, and sets</title><link>https://sciencecomputing.io/data-structures/tuples-named-tuples-and-sets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/data-structures/tuples-named-tuples-and-sets/</guid><description>&lt;p>In this module, we will explore data structures that look a lot like arrays,
but have subtly different use cases: tuples, named tuples, and sets. Knowing
when to use arrays and when to use others data structure can really make a
difference in your programming!s&lt;/p></description></item><item><title>Type stability</title><link>https://sciencecomputing.io/advanced-functions/type-stability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/advanced-functions/type-stability/</guid><description>&lt;p>In this module, we will talk about &lt;em>type stability&lt;/em>, and see how we can
annotate the functions in &lt;em>Julia&lt;/em> to be explicit about what type they return.&lt;/p></description></item><item><title>Types</title><link>https://sciencecomputing.io/fundamentals/types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/fundamentals/types/</guid><description>&lt;p>In this module, we will look at one of the most important concept in &lt;em>Julia&lt;/em>:
types. Types are, to be really imprecise, the way a programming language
thinks about a value. A lot of problems arise from the fact that programming
languages are very opinionated.&lt;/p></description></item><item><title>Understanding dispatch</title><link>https://sciencecomputing.io/functions/understanding-dispatch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/functions/understanding-dispatch/</guid><description>&lt;p>The point of this module is to understand &lt;em>dispatch&lt;/em>, which is to say, the way
the correct method is called based on the arguments; we will also see how to
use it to write the least possible amount of code!&lt;/p></description></item><item><title>Working with delimited files</title><link>https://sciencecomputing.io/files/working-with-delimited-files/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/files/working-with-delimited-files/</guid><description>&lt;p>A lot of files we use in scientific computing are very simple, and organized
as tables. There are a lot of packages in &lt;em>Julia&lt;/em> to handle these files,
including the full-featured &lt;span class='package'>&lt;span class='pkgname'>&lt;a href='https://juliapackages.com/p/DataFrames' target='_blank'>DataFrames&lt;/a>&lt;/span>&lt;/span> and &lt;span class='package'>&lt;span class='pkgname'>&lt;a href='https://juliapackages.com/p/DataFramesMeta' target='_blank'>DataFramesMeta&lt;/a>&lt;/span>&lt;/span>. But in this
module, we will focus on the standard library package &lt;span class='package no-hub'>&lt;span class='pkgname'>DelimitedFiles&lt;/span>&lt;/span>,
which allows to store files where fields are separated by a specified
character.&lt;/p></description></item></channel></rss>