<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://sciencecomputing.io/05_advanced_functions_usage/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://sciencecomputing.io/05_advanced_functions_usage/index.xml" rel="self" type="application/rss+xml"/><item><title>Dispatch on element types</title><link>https://sciencecomputing.io/advanced-functions/dispatch-on-element-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/advanced-functions/dispatch-on-element-types/</guid><description>&lt;p>In this lesson, we will see how we can dispatch on parametric types, in order
to have a fine-grained control on what method is used for different
types of data collections. This is a core design pattern in &lt;em>Julia&lt;/em>, and we will
illustrate it by building some functions related to measuring the distances between
points.&lt;/p></description></item><item><title>Mutating functions</title><link>https://sciencecomputing.io/advanced-functions/mutating-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/advanced-functions/mutating-functions/</guid><description>&lt;p>In this module, we will see how &lt;em>Julia&lt;/em> deals with collections when they are
passed as arguments to a function, why this can be terrifying when coming from
other languages that are less concerned with economy of memory, and how we can
use this behavior to write more efficient code.&lt;/p></description></item><item><title>Recursion</title><link>https://sciencecomputing.io/advanced-functions/recursion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/advanced-functions/recursion/</guid><description>&lt;p>What is recursion, if not recursion persevering? In this module, we will see
how to call functions recursively, and discuss when this is appropriate in
real life.&lt;/p></description></item><item><title>Testing functions</title><link>https://sciencecomputing.io/advanced-functions/testing-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/advanced-functions/testing-functions/</guid><description>&lt;p>In this module, we will explore the &lt;code>Test&lt;/code> package, which allows to
programmatically test the behavior of a function. We will see how testing can
bring us closer to being confident in our code.&lt;/p></description></item><item><title>Type stability</title><link>https://sciencecomputing.io/advanced-functions/type-stability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/advanced-functions/type-stability/</guid><description>&lt;p>In this module, we will talk about &lt;em>type stability&lt;/em>, and see how we can
annotate the functions in &lt;em>Julia&lt;/em> to be explicit about what type they return.&lt;/p></description></item></channel></rss>