<!doctype html><html><head>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta charset=utf-8>
<link href=/fonts/fontawesome/css/fontawesome.css rel=stylesheet>
<link href=/fonts/fontawesome/css/brands.css rel=stylesheet>
<link href=/fonts/fontawesome/css/solid.css rel=stylesheet>
<script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0,theme:"neutral",curve:"linear"})</script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script>
<link rel=stylesheet href=https://sciencecomputing.io/index.818233115a5ddaf75da6d0ea23b08181cba7bdd5657dda146098a1d667db9950.css>
<title>Map, Filter, Accumulate, Reduce · Scientific computing</title></head><body><header>
<div id=reading-bar><div id=reading-bar-inner></div></div><img class=logo src=/logo.svg>
<h1><a href=/>Scientific computing</a></h1><h2>(for the rest of us)</h2></header><main>
<h1>Map, Filter, Accumulate, Reduce</h1><article>
<p>In a lot of applications, we want to apply some operation to all elements in a
collection, and then aggregate these elements together in a grand unified
answer. In this module, we will have a look at the map-filter-reduce strategy,
as well as the accumulate operation.</p><p>Calculating an average. Easy, right? We load <span class=package><span class=pkgname><a href=https://juliapackages.com/p/Statistics target=_blank>Statistics</a></span></span>, and call <code>mean</code>.
What if we made it fun? What if we made it way, way more complicated than it
has any right to be?</p><p>Let&rsquo;s take a vector $\mathbf{x}$. The average value of $\mathbf{x}$ is its sum
divided by its length:</p><p>$$
\frac{x_1}{n} + \frac{x_2}{n} + &mldr; + \frac{x_n}{n}
$$</p><p>In other words, for every element $x_i$, we want to divide it by $n$, and then
we want to reduce all of these using the sum operation. This is a task for
<code>map</code> and <code>reduce</code>.</p><p>The <code>map</code> function will take a function as argument, and apply it to every
element of a collection. For example, this is a way to use <code>map</code> to double
every entry in an array:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>map</span><span class=p>(</span><span class=n>e</span> <span class=o>-&gt;</span> <span class=mi>2</span><span class=n>e</span><span class=p>,</span> <span class=n>x</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>4-element Vector{Int64}:
 2
 4
 6
 8
</code></pre><p>On the other hand, <code>reduce</code> accepts a binary operator (something requiring two
arguments), and applies it sequentially alongside an array until a single
value remains. For example, the sum of an array expressed as <code>reduce</code> is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>y</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>reduce</span><span class=p>(</span><span class=o>+</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>12
</code></pre><p>And so, we have enough to build a very crude function to get the average of an
array of values:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>7</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>n</span> <span class=o>=</span> <span class=n>length</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>reduce</span><span class=p>(</span><span class=o>+</span><span class=p>,</span> <span class=n>map</span><span class=p>(</span><span class=n>e</span> <span class=o>-&gt;</span> <span class=n>e</span> <span class=o>/</span> <span class=n>n</span><span class=p>,</span> <span class=n>x</span><span class=p>))</span>
</span></span></code></pre></div><pre tabindex=0><code>4.0
</code></pre><div class="callout warning">The <code>reduce</code> operation has no well defined behavior when using an
operator without associativity, like a substraction. This is because
<code>reduce(-, [a,b,c])</code> can be <code>a-(b-c)</code> or <code>(a-b)-c</code>; the documentation for
<code>reduce</code> has a number of alternatives to suggest.</div><p>Another function that is often used together with <code>map</code> and <code>reduce</code> is
<code>filter</code>. The <code>filter</code> function evaluates a condition on every element of a
collection:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>filter</span><span class=p>(</span><span class=n>isodd</span><span class=p>,</span> <span class=mi>1</span><span class=o>:</span><span class=mi>10</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>5-element Vector{Int64}:
 1
 3
 5
 7
 9
</code></pre><p>Using <code>filter</code> can be done <em>before</em> <code>map</code> (we want to apply on operation, but
only on some elements), or <em>after</em> <code>map</code> (we want to apply the operation and
see where we stand). This sequence of operations is commonly known as
map-filter-reduce, and is a very expressive way of chaining together
operations.</p><p>Another related function is <code>accumulate</code>, which works much like <code>reduce</code> but
without collapsing the vector to a single element. For example the sequence of
$n!$ is</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>accumulate</span><span class=p>(</span><span class=o>*</span><span class=p>,</span> <span class=mi>1</span><span class=o>:</span><span class=mi>5</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>5-element Vector{Int64}:
   1
   2
   6
  24
 120
</code></pre><p>and the cumulative sum of an array is</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>accumulate</span><span class=p>(</span><span class=o>+</span><span class=p>,</span> <span class=mi>1</span><span class=o>:</span><span class=mi>5</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>5-element Vector{Int64}:
  1
  3
  6
 10
 15
</code></pre><p>Chained together, these four functions can get <em>really</em> powerful. For example,
we can use <code>accumulate</code> to write a logistic growth model in a single line. We
can define some parameters:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>r</span><span class=p>,</span> <span class=n>K</span><span class=p>,</span> <span class=n>n₀</span> <span class=o>=</span> <span class=mf>2.3</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>,</span> <span class=mf>0.01</span>
</span></span></code></pre></div><pre tabindex=0><code>(2.3, 1.0, 0.01)
</code></pre><p>We can now define a model that takes two arguments, as per the documentation
of <code>accumulate</code> (which you should definitely read):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>model</span> <span class=o>=</span> <span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>_</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>n</span> <span class=o>+</span> <span class=n>n</span> <span class=o>*</span> <span class=n>r</span> <span class=o>*</span> <span class=p>(</span><span class=mi>1</span> <span class=o>-</span> <span class=n>n</span> <span class=o>/</span> <span class=n>K</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>#5 (generic function with 1 method)
</code></pre><p>And run it for a number of steps defined by the array; note that we use the
<code>init</code> keyword to &ldquo;seed&rdquo; the process with a value of our choice, here the
initial population size:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=line><span class=cl><span class=n>nt</span> <span class=o>=</span> <span class=n>accumulate</span><span class=p>(</span><span class=n>model</span><span class=p>,</span> <span class=n>zeros</span><span class=p>(</span><span class=kt>Float64</span><span class=p>,</span> <span class=mi>10</span><span class=p>);</span> <span class=n>init</span> <span class=o>=</span> <span class=n>n₀</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>10-element Vector{Any}:
 0.03277
 0.10567109233
 0.3230319312543046
 0.8260012273364679
 1.156564586819236
 0.7400873564894737
 1.1825108973734353
 0.6861223097964039
 1.1814468271273222
 0.6883963372629648
</code></pre><p>This is a time-discrete model with no loop!</p><div class="callout information">The <code>map</code> function has a variant for arrays with more than one
dimension called <code>mapslices</code>, which works on slices of high-dimensional
arrays. It&rsquo;s useful to perform, <em>e.g.</em>, row-wise or column-wise operations on
matrices.</div></article></main><footer>
<div class=wrapper>
<a href=/about/>About this project</a>
<a href=https://github.com/tpoisot/ScientificComputingForTheRestOfUs target=_blank>See the project on GitHub</a>
<a href="https://github.com/tpoisot/ScientificComputingForTheRestOfUs/issues/new?labels=section-advanced_topics,module-filtering,status-rc,feedback&assignees=@tpoisot&title=ADD%20A%20DESCRIPTIVE%20TITLE&body=%20**Description%20of%20your%20problem/comments**%0a%0a%0a%0a---%0a*Do%20not%20edit%20below%20this%20point*%0a%0a[%f0%9f%92%bb%20SOURCE][src]%0a%0a[src]:%20https://github.com/tpoisot/ScientificComputingForTheRestOfUs/blob/main/content/06_advanced_topics/01_filtering.jl%0a%0a[%f0%9f%93%94%20PAGE][prm]%0a%0a[prm]:%20https://sciencecomputing.io/advanced-topics/map-filter-accumulate-reduce/%0a%0a%f0%9f%93%a6%20section-advanced_topics%0a%0a%f0%9f%8f%b7%ef%b8%8f%20module-filtering" target=_blank>Provide feedback on this module</a>
<a href=https://creativecommons.org/licenses/by/4.0/ target=_blank>CC-BY 4.0 (Timothée Poisot)</a>
</div></footer></body><script>const readingBarInner=document.querySelector("#reading-bar-inner");document.addEventListener("scroll",function(){let e=(document.body.scrollTop||document.documentElement.scrollTop)/(document.documentElement.scrollHeight-document.documentElement.clientHeight)*100;readingBarInner.style.setProperty("width",e+"%")})</script>
</html>