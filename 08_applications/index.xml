<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://sciencecomputing.io/08_applications/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://sciencecomputing.io/08_applications/index.xml" rel="self" type="application/rss+xml"/><item><title>Building our own graph library</title><link>https://sciencecomputing.io/applications/building-our-own-graph-library/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/applications/building-our-own-graph-library/</guid><description>&lt;p>In this module,&lt;/p></description></item><item><title>Linear regression using gradient descent</title><link>https://sciencecomputing.io/applications/linear-regression-using-gradient-descent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/applications/linear-regression-using-gradient-descent/</guid><description>&lt;p>In this module, we will use the gradient descent algorithm to perform a linear
regression, to estimate the brain mass of an animal if we know its body mass.
This will draw on concepts from a number of previous modules, while also
presenting an example of how core programming skills can be applied for
research.&lt;/p></description></item><item><title>Naive Bayes Classifier</title><link>https://sciencecomputing.io/applications/naive-bayes-classifier/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/applications/naive-bayes-classifier/</guid><description>&lt;p>Naive Bayes Classifiers are formidable because they can learn so much about a
dataset based on relatively scarce information. In this module, we will build
one from scratch, using (mostly) methods from &lt;em>Julia&lt;/em>&amp;rsquo;s standard library.&lt;/p></description></item><item><title>Runge-Kutta for numerical integration</title><link>https://sciencecomputing.io/applications/runge-kutta-for-numerical-integration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/applications/runge-kutta-for-numerical-integration/</guid><description/></item><item><title>The forest-fire model</title><link>https://sciencecomputing.io/applications/the-forest-fire-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/applications/the-forest-fire-model/</guid><description>&lt;p>In this module, we will have a look at indexing in order to simulate the
behavior of a forest when trees can catch on fire, be planted, and regrow.
This is a common example in complex system studies, and produces very visually
pleasing structures in space! As a treat, we will spend a little more time
learning about how &lt;span class='package'>&lt;span class='pkgname'>&lt;a href='https://juliapackages.com/p/Makie' target='_blank'>Makie&lt;/a>&lt;/span>&lt;/span> works.&lt;/p></description></item><item><title>The travelling salesperson problem</title><link>https://sciencecomputing.io/applications/the-travelling-salesperson-problem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sciencecomputing.io/applications/the-travelling-salesperson-problem/</guid><description>&lt;p>In this module, we will look at a way to start working on the travelling salesperson
problem. This is mostly an excuse to play with simulated annealing, which is a really cool
optimisation algorithm.&lt;/p></description></item></channel></rss>